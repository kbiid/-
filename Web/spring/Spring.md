## 스프링이란?
- 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크

## 애플리케이션 프레임워크

- 애플리케이션 프레임워크 : 일반적으로 라이브러리나 프레임워크는 특정 업무 분야나 한 가지 기술에 특화된 목표를 가지고 만들어진다. 하지만 스프링은 이와 다르게 '애플리케이션 프레임워크'라는 특징을 갖고 있다. 애플리케이션 프레임워크는 특정 계층이나, 기술, 업무 분야에 국한되지 않고 애플리케이션의 전 영역을 포괄하는 범용적인 프레임워크를 말한다. 애플리케이션 개발의 전 과정을 빠르고 편리하며 효율적으로 진행하는데 일차적인 목표를 두는 프레임워크이다.
- 스프링의 기원된 예제 애플리에키션의 프레임워크는 책에서 설명한 각종 자바 엔터프라이즈 개발 전략의 핵심을 담아서 개발했다. 
- 애플리케이션의 전 영역을 관통하는 일관된 프로그래밍 모델과 핵심 기술을 바탕으로 해서 각 분야의 특성에 맞는 필요를 채워주고 있기 때문에, 애플리케이션을 빠르고 효과적으로 개발할 수가 있다. 바로 이것이 스프링이 애플리케이션 프레임워크라고 불리는 이유이다.
- 스프링의 일차적은 존재 목적은 핵심 기술에 담긴 프로그래밍 모델을 일관되게 적용해서 엔터프라이즈 애플리케이션 전 계층과 전 영역에 전략과 기능을 제공해줌으로써 애플리케이션을 편리하게 개발하게 해주는 애플리케이션 프레임워크로 사용되는 것임을 기억해 두는 것이 좋다.

## 경량급

- EJB가 동작하기 우해서 고가의 느리고 무거운 자바 서버(WAS)가 필요한 것과는 달리, 스프링은 가장 단순한 서버환경인 톰캣(Tomcat)인 제티(Jetty)에서도 완벽하게 동작한다. 단순한 개발툴과 기본적인 개발환경으로도 엔터프라이즈 개발에서 필요로 하는 주요한 기능을 갖춘 애플리케이션을 개발하기에 충분하다. 스프링의 장점은 가볍고 단순한 환경에서도 복잡한 EJB와 고가의 WAS를 갖춰야만 가능했던 엔터프라이즈 개발의 고급 기술을 대부분 사용할 수 있다는 점이다. 만들어진 코드가 지원하는 기술수준은 비슷하더라도 그것을 훨씬 빠르고 간편하게 작성하게 해줌을써 생산성과 품질 면에서 유리하다는 것이 스프링의 특징이다.

## 자바 엔터프라이즈 개발을 편하게

- 스프링은 애플리케이션 개발자들이 스프링이라는 프레임워크가 제공하는 기술이 아니라 자신이 작성하는 애플리케이션의 로직에 더 많은 관심과 시간을 쏟게 해준다. 초기에 스프링의 기본 설정과 적용 기술만 잘 선택하고 준비해두면, 이후로 애플리케이션 개발 중에는 스프링과 관련된 코드나 API에 대해 개발자가 신경 쓸 일이 없다. 엔터프라이즈 개발에서 필연적으로 요구되는 기술적인 요구를 충족하면서도 개발을 복잡하게 만들지 않는다는 점이 스프링의 뛰어난 면이다.

## 오픈소스

- 오픈소스란 말 그대로 소스가 모두에게 공개되고, 특별한 라이선스를 취득할 필요없이 얼마든지 가져다 자유롭게 이용해도 된다는 뜻이다. 소스를 자유롭게 열람하고 자신의 목적에 맞게 사용할 수 있을 뿐만 아니라, 필요하면 맘대로 수정할 수 있고, 수정된 제품과 소스를 다시 공개적으로 배포하는 자유도 허용된다. 물론 오픈소스도 저작권이 있기 때문에 원 저작자에 대한 정보와 라이선스는 유지한 채로 사용하거나 배포해야 한다.

- 스프링에 적용된 오픈소스 라이선스는 비교적 제약이 적고 사용이 매우 자유로운 편인 아파치 라이선스 버전 2.0(Apache)이다. 아파치 라이선스에 따르면 스프링을 상업적인 목적의 제품에 포함시키거나 비공개 프로젝트에 자유롭게 이용해도 된다. 다만, 스프링을 사용한다는 점과 원 저작자를 밝히고 제품을 패키징할 때 라이선스 정보를 포함시키는 등의 기본적인 의무사항을 따르면 된다. 또, 필요하다면 스프링 소스코드를 가져와 수정해서 사용할 수도 있다. 수정을 했더라도 수정한 소스를 공개해야 하는 의무는 없다.

- 오픈소스의 장점은 공개된 커뮤니티의 공간 안에서 투명한 방식으로 다양한 참여를 통해 개발되기 때문에 매우 빠르고 유연한 개발이 가능하다는 것이다. 오픈소스 제품의 사용자는 소스코드를 다운받아서 품질과 기능을 얼마든지 검증하고 분석해볼 수 있다. 발견한 버그를 신고하거나 기능 개선을 제안했다면 그것이 어떻게 처리되는지도 지켜볼 수 있다. 개발 중인 경우에도 소스코드까지 투명하게 공개되기 때문에 다양한 현장에 있는 사용자의 피드백이 그만큼 빨리 전달되고 반영된다.

- 오픈소스 개발 방식의 가장 큰 취약점은 지속적이고 안정적인 개발이 계속될지가 불확실하다는 것이다. 오픈 소스 프로젝트는 특히 개발자 개개인에게 극히 의존적이다. 스프링 개발자는 이런 오픈소스의 문제점과 한계를 잘 알고 있었다. 그래서 오픈소스 개발이라는 방법을 선택했지만 프레임워크 사용자에게 지속적인 신뢰를 줄 수 있도록 개발을 책임지고 진행할 수 있는 전문 기업을 만들었다.

## 스프링의 목적

### 엔터프라이즈 개발의 복잡함

- 복잡함의 근본적인 이유

  1. 기술적인 제약조건과 요구사항이 늘어나기 때문이다.

    - 엔터프라이즈 시스템이란 서버에서 동작하며 기업과 조직의 업무를 처리해주는 시스템을 말한다. 많은 사용자의 요청을 동시에 처리해야 하기 때문에    서버의 자원을 효율적으로 공유하고 분배해서 사용할 수 있어야 한다. 또한, 중요한 기업의 핵심 정보를 처리하거나 미션크리티컬한 금융, 원자력, 항공, 국방 등의 시스템을 다루기도 하기 때문에 보안과 안정성, 확장성 면에서도 뛰어나야 한다. 따라서 뛰어난 성능과 서비스의 안정성이 요구되고 그런 점을 고려한 개발 기술이 필요하다. 즉, 엔터프라이즈 시스템을 개발하는 데는 순수한 비즈니스 로직을 구현하는 것 외에도 기술적으로 고려할 사항이 많다는 뜻이다. 
    
  2. 엔터프라이즈 애플리케이션이 구현해야 할 핵심기능인 비즈니스 로직의 복잡함이 증가하기 때문이다.
    - 갈수록 엔터프라이즈 시스템을 이용해 기업의 핵심 업무를 처리하는 비율이 늘어갔고, 점차 대부분의 업무 처리는 컴퓨터를 이용하지 않고는 아예 진행하기 힘들 만큼 엔터프라이즈 시스템에 대한 업무 의존도가 높아졌다. 그만큼 다양하고 복잡한 업무 처리 기능을 엔터프라이즈 시스템이 구현해야 했다는 뜻이다.
    
- 복잡함을 가중시키는 원인

  - 자바 엔터프라이즈 시스템 개발이 어려운 가장 큰 이유는 근본적인 비즈니스 로직과 엔터프라이즈 기술이라는 두 가지 복잡함이 한데 얽혀 있기 때문이다. 전통적인 자바 엔터프라이즈 개발 기법은 대부분 비즈니스 로직의 복잡한 구현 코드와 엔터프라이즈 서비스를 이용하는 기술적인 코드가 자꾸 혼재될 수 밖에 없는 방식이었다.
  
### 복잡함을 해결하려는 도전

- 제거될 수 없는 근본적인 복잡함 : 근본적으로 엔터프라이즈 개발에 나타나는 복잡함의 원인은 제거 대상이 아니다. 대신 그 복잡함을 효과적으로 상대할 수 있는 전략과 기법이 필요하다. 문제는 비즈니스 로직의 복잡함을 효과적으로 다루기 위한 방법과 기술적인 복잡함을 효과적으로 처리하는 데 적용되는 방법이 다르다는 점이다. 따라서 두 가지 복잡함이 코드에 한데 어우러져 나타나는 전통적인 개발 방식에서는 효과적으로 복잡함을 다루기 힘들다.

- 실패한 해결책인 EJB

  - EJB의 기본 적략도 이 두가지 종류의 복잡함을 분리하는 것이었다. 선언전 트랜잭션, 선언적 보안, 컨테이너를 통한 리모팅 기술의 적용, 컴포넌트 단위의 배치, JNDI를 통한 서비스 검색 지원, 서비스 오브젝트의 풀링, 컴포넌트 생명주기 관리 등은 어느 정도 충족시켰지만 EJB 환경에서 동작하기 위해 특정 인터페이스를 구현하고, 특정 클래스를 상속하고, 서버에 종속저인 서비스를 통해서만 접근하고 사용이 가능하게 만드는 등의 EJB 개발 방식은 잘못된 선택이었다. 애플리케이션 로직을 담은 핵심 코드에서 일부 기술적인 코드가 제거된 건 사실이지만, 오히려 EJB라는 환경과 스펙에 종속되는 코드로 만들어져야 하는 더 큰 부담을 안게 됬다.
  
  - EJB라는 틀 안에서 자바 코드를 만들게 강제함으로써 자바 언어가 원래 갖고 있던 장점마저 잃어버렸다는 사실이다. EJB는 특정 클래스를 상속하게 함으로써 더 이상 상속구조를 적용하지 못하게 만들거나, 다형성 적용을 근본적으로 제한한다거나 하는 것들이다. 
  
- 비침투적인 방식을 통한 효과적인 해결책: 스프링

  - EJB처럼 어떤 기술을 적용했을 때 그 기술과 관련된 코드나 규약 등이 코드에 등장하는 경우를 침투적인 기술이라고 한다. 꼭 필요한 기능을 사용하는 것도 아니면서 단지 어떤 기술을 바탕으로 만들어진다고해서 특정 클래스나 인터페이스, API 등의 코드에 마구 등장한다면 그것은 침투적인 기술이 되며 복잡함을 가중시키는 원인이 된다.
  
  - 반면에 비침투적인(non-invasive) 기술은 기술의 적용 사실이 코드에 직접 반영되지 않는다는 특징이 있다. 어딘가에는 기술의 적용에 따라 필요한 작업을 해줘야 겠지만, 애플리케이션 코드 여기저기에 불쑥 등장하거나, 코드의 설계와 구현 방식을 제한하지는 않는다는 게 비침투적인 기술의 특징이다.
  
  - 스프링은 비침투적인 기술이라는 전략을 택했기 때문에 성공했다. 스프링을 이용하면 기술적인 복잡함과 비즈니스 로직을 다루는 코드를 깔끔하게 분리할 수 있다. 중요한 점은 그 과정에서 스프링 스스로가 애플리케이션 코드에 불필요하게 나타나지 않도록 하는 것이다. 꼭 필요한 것 같은 경우조차도 기술 코드가 직접 노출되지 않도록 만들어줬다.
  
### 복잡함을 상대하는 스프링의 전략

  - 기술적 복잡함을 상대하는 전략
  
    1. 기술에 대한 접근 방식이 일관성이 없고, 특정 환경에 종속적이다. : 일관성 없는 기술과 서버환경의 변화에 대한 스프링의 공략 방법은 바로 서비스 추상화다. 트랜잭션 추상화, OXM 추상화, 데이터 액세스에 관한 일관된 예외변환 기능, 데이터 액세스 기술에 독립적으로 적용 가능한 트랜잭션 동기화 기법 등이 예다. 기술적인 복잡함은 일단 추상화를 통해 로우레벨의 기술 구현 부분과 기술을 사용하는 인터페이스를 분리하고, 환경과 세부 기술에 독립적인 접근 인터페이스를 제공하는 것이 가장 좋은 해결책이다. 스프링이 제공하는 템플릿/콜백 패턴은 반복적인 작업 흐름과 API 사용 코드를 제거해준다. 이를 통해 기술을 사용하는 코드도 최적화된 핵심 로직에만 집중하도록 도와준다.
    
    2. 기술적인 처리를 담당한느 코드가 성격이 다른 코드에 섞여서 등장한다. : 기술과 비즈니스 로직의 혼재로 발생하는 복잡함을 해결하기 위한 스프링의 접근 방법은 바로 AOP다. AOP는 최후까지 애플리케이션 로직을 담당하는 코드에 남아 있는 기술 관련 코드를 깔끔하게 분리해서 별도의 모듈로 관리하게 해주는 강력한 기술이다. AOP를 적용하지 않았을 때는 기술과 비즈니스 로직이 지저분하게 얽혀서 다루기 힘들다는 문제도 있지만, 기술적인 코드가 여기저기 중복돼서 나타난다는 것도 심각한 문제점이다. AOP는 기술을 다루는 코드로 인한 복잡함을 기술 그 자체 이상으로 불필요하게 증대되지 않도록 도와주는 가장 강력한 수단이다.
    
### 비즈니스와 애플리케이션 로직의 복잡함을 상대하는 전략

- 비즈니스 로직을 담은 코드는 애플리케이션에서 가장 중요한 핵심이 되는 부분이다. 또한 업무의 변화에 따라 자주 변경되거나 수정되는 부분이기도 하다. 기술적인 부분이나 사용자 인터페이스에 관한 오류가 발생했을 경우에는 시스템을 복구하거나 빠르게 대응해주면 당장에 큰 문제가 발생하지는 않는다. 반면에 비즈니스 로직을 다루는 핵심 코드에 오류가 있으면 엔터프라이즈 시스템을 사용하는 업무 자체에 큰 지장을 주거나 치명적인 손실을 끼칠 수도 있다. 

- 엔터프라이즈 시스템의 규모가 커지고, 복잡함이 증가하면서 DB에 비즈니스 로직을 두는 건 매우 불편할뿐더러 위험한 일이라고 여겨지기 시작했다. 가장 확장하기도 힘들고 확장하더라도 많은 비용이 드는 공유 자원인 DB에 커다란 부담을 주는 것도 문제고, 데이터 액세스를 중심으로 로직을 다루면 개발과 유지보수는 물론이고 테스트도 매우 어렵게 된다.

- 엔터프라이즈 시스템 개발의 흐름은 비즈니스 로직은 애플리케이션 안에서 처리하도록 만드는 추세이다. DB는 단지 데이터의 영구적인 저장과 복잡한 조건을 가진 검색과 같은 자체적으로 특화된 기능에만 활용하고, 데이터를 분석하고 가공하고 그에 따라 로직을 처리하는 부분은 확장하기 쉽고, 비용도 싼 애플리케이션 서버 쪽으로 이동하는 것이다.

- 객체지향 분석과 설계(OOAD)를 통해서 작성된 모델을 코드로 구현하고 지속적으로 발전시킬 수도 있다. 결국, 비즈니스 로직의 복잡함을 상대하는 전략은 자바라는 객체지향 기술 그 자체이다. 스프링은 단지 객체지향 언어의 장점을 제대로 살리지 못하게 방해했던 요소를 제거하도록 도와줄 뿐이다.

### 핵심 도구 : 객체 지향과 DI



## 스프링의 특징
<ul>
  <li>경량(Light-weighted) : 크기와 부하 측면에서 독립된 몇 개의 jar 파일로 구성되어 있기 때문에 설치가 용이하며 POJO를 사용한다.</li>
  <li>IoC 패턴 : 객체 사이의 의존관계를 코드로 구현하지 않고 Framework에 의해 주입받는다.(Dependency Injection)</li>
  <li>AOP(Aspect Of Control) : 핵심 로직 개발 시 Transaction 지원이나 Loggin, Security 등 시스템 적 관심사에 신경쓸 필요가 없다.</li>
  <li>Transaction 관리 : Java Object 들에 대한 트랜잭션을 지원하지만 결코 J2EE와 같은 환경에 얽매이지 않는다.</li>
  <li>Container : Application 객체의 Life cycle과 객체들 간 의존관계를 컨테이너 형태로 관리한다. Servlet Container와 Spring container의 차이점은 특정 WAS. 벤더에 종속적이지 않으면서 자유로운 확장이 가능하다는 것이다.</li>
  <li>Framework : 간단한 컴포넌트 만으로도 Application 구성이 가능하다. xml 설정 파일 상의 선언적인 구성도 가능하다.</li>
  <li>Integration : Container 구조 덕분에 다른 프레임워크들과 결합이 쉽다. 특히 IBATIS, Hibernate 등과의 결합은 공식과도 같다.</li>
</ul>

## 스프링의 핵심
<ul>
  <li>POJO : Plain Old Java Object.</li>
  <li>DI : Dependency Injection</li>
  <li>AOP</li>
  <li>PSA : Portable Service Abstractions</li>
</ul>

## POJO
- 진정한 POJO란 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트를 말한다. 그런 POJO에 애플리케이션의 핵심 로직과 기능을 담아 설계하고 개발하는 방법을 POJO프로그래밍이라고 할 수 있다.
- POJO의 조건
  <ul><li>특정 규약(Contract)에 종속되지 않는다 : POJO는 자바 언어와 꼭 필요한 API 외에는 종속되지 않아야 한다. 따라서 EJB2와 같이 특정 규약을 따라 비즈니스 컴포넌트를 만들어야 하는 경우는 POJO가 아니다. 특정 규약을 따르는 경우 특정 클래스를 상속하도록 요구한다. 그럴 경우 자바의 단일 상속 제한 때문에 해당 클래스에 객체지향적인 설계 기법을 적용하기가 어려워지는 문제가 생긴다. 또 규약이 적용된 환경에 종속적이라 다른 환경으로 이전이 힘들다. 규약에 종속되지 않아야 하고, 객체지향 설계의 자유로운 적용이 가능한 오브젝트여야만 POJO라고 할 수 있다.</li>
  <li>특정 환경에 종속되지 않는다 : 순수한 애플리케이션 로직을 담고 있는 오브젝트 코드가 특정 환경에 종속되게 만들거나 애노테이션이나 엘리먼트 값에 특정 기술과 환경에 종속적인 정보를 담고 있다면 POJO라고 할 수 없다.</li></ul>
- POJO의 장점
  <ul>
  <li>특정한 기술과 환경에 종속되지 않는 오브젝트는 코드가 깔끔해진다.</li>
  <li>매우 유연한 방식으로 원하는 레벨에서 코드를 빠르고 명확하게 테스트할 수 있다.</li>
  <li>객체지향적인 설계를 자유롭게 적용할 수 있다.</li>
  </ul>
## 버전별 특징
<ul>
  <li>Spring 3.0 : Spring 3.0부터 Java5가 지원된다. 기존에 유지하던 하위호환성에 Generic이나 가변인자(varargs) 등과 같은 개선사항이 추가된다.
    <ul><li>전체 프레임워크를 하나의 spring.jar 파일로 제공하던 부분을 여러개의 jar 파일로 나누어 제공한다.</li>
      <li>SPEL(Spring Expression Language)가 도입되었다.</li>
      <li>Rest API에 대한 지원이 추가되었다.</li>
      <li>OXM(Object Xml Mapping) 기능이 추가되어 설정을 Xml형태로 할 수 있게 지원한다.</li>
      <li>Java annotation을 이용해서 DI의 지원이 가능하다.</li></ul></li>
  <li>Spring 4.0 : Java 8의 특징들을 적용할 수 있게 지원한다.
    <ul><li>Starter Pack이 생겨서 초보 개발자들에게 큰 진입장벽인 POM 설정을 도와준다.</li>
    <li>기존에 사용하지 않지만 호환성을 위해 남겨져있던 Deprecated Package들이 제거되었으며 Hibernate 3.6이상, EhCache 2.1 이상, Groovy 1.8이상, Joda-Time 2.0 이상 등 새로운 Dependency 들에 대해 지원한다.</li>
    <li>Java6, Java7, Jva8의 고유 기능들에 대해 지원한다. 람다식, Optional, Callback Interface 등의 기능을 Spring framework 레벨에서 사용할 수 있다.</li>
    <li>Java EE 6, 7에 대해 고려되어 있다. JPA 2.0과 Servlet 3.0에 대한 지원이 포함되어 있다는 뜻이다.</li>
    <li>Groovy를 이용한 Bean 설정이 가능하다. GroovyBeanDefinitionReader 문서를 참조할 것.</li>
    <li>Core 컨테이너들의 기능 지원이 확대되어있다. 먼저 Repository 들이 좀 더 쉽게 Inject될 수 있으며, 각종 Metadata Annotation들을 이용한 Custom Annotation 작성이 가능하다. @Lazy를 이용한 Lazy Injection이나 @Order을 통한 Interface, @Profile을 통한 프로필 버전 관리가 쉬워졌다.</li>
    <li>Web을 개발하기 위한 도구들이 생겼다. @RestController 같은 것들이 그것이다.</li>
    <li>Web Socket이나 STOMP등의 프로토콜을 같이 지원한다.</li>
    <li>테스트 환경이 개선되었다. Framework 레벨에서 Mock을 위한 ServletContext를 별도로 지원한다.</li></ul></li>
  <li>Spring5.0 : JDK 8+,9 등에 대해서 지원하며 Java8을 표준으로 사용한다.
  <ul><li>코어로직에 있어서 JDK 8의 특징들이 강화되었다.</li>
    <li>HTTP 메시지 코덱의 XML과 JSON 지원에 대한 구현이 Encoder와 Decoder의 사용을 통해 추상화 되었다.</li>
    <li>웹에 대한 지원이 향상되었다. 특히 Protobuf3.0지원이 적용되었다.</li>
    <li>https://atin.tistory.com/626</li></ul></li>
</ul>

## Annotation
- https://gmlwjd9405.github.io/2018/12/02/spring-annotation-types.html

## Filter
- 요청과 응답을 거른 뒤 정제하는 역할.
- 서블릿 필터는 DispatcherServlet 이전에 실행이 되는데 필터가 동작하도록 지정된 자원의 앞단에서 요청 내용을 변경하거나, 여러가지 체크를 수행할 수 있다. 자원의 처리가 끝난 후 응답내용에 대해서도 변경하는 처리를 할 수가 있다.
- 보통 web.xml에 등록하고, 일반적으로 인코딩 변환 처리, XSS방어 등의 요청에 대한 처리로 사용된다.
- 실행 메소드
  <ul>
  <li>init() : 필터 인스턴스 초기화</li>
  <li>doFilter() : 전/후 처리</li>
  <li>destroy() : 필터 인스턴스 종료</li>
  </ul>

## Interceptor
- 요청에 대한 작업 전/후를 가로챈다.
- 필터는 스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해 동작한다. 하지만 인터셉터는 스프링의 DispatcherServlet이 컨트롤러를 호출하기 전후로 끼어들기 때문에 스프링 컨텍스트(Context, 영역) 내부에서 Controller(Handler)에 관한 요청과 응답에 대해 처리한다. 스프링의 모든 빈 객체에 접근할 수 있다.
- 인터셉터는 여러 개를 사용할 수 있고 로그인 체크, 권한 체크, 프로그램 실행시간 계산 작업 로그 확인 등에 사용한다.
- 실행 메소드
  <ul>
  <li>preHandler() : 컨트롤러 메소드가 실행되기 전</li>
  <li>postHandler() : 컨트롤러 메소드 실행직후 view페이지 렌더링 되기 전</li>
  <li>afterCompletion() : view 페이지가 렌더링 되고 난 후</li>
  </ul>
## 참고
- https://12bme.tistory.com/157
- https://goddaehee.tistory.com/154
