## Serialization
- 직렬화란? : 자바 시스템 내부에서 사용되는 Obejct 또는 Data를 외부의 자바 시스템에서도 사용할 수 있도록 byte 형태로 데이터를 변환하는 기술. JVM의 메모리에 상주(힙 또는 스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술
- 역직렬화(Deserialization) : byte로 변환된 Data를 원래대로 Obejct나 Data로 변환하는 기술을 역직렬화라고 부른다. 직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM으로 상주시키는 형태.
- 자바 직렬화 형태의 데이터 교환은 자바 시스템 간의 데이터 교환을 위해서 존재한다.

## transient
- 객체의 데이터 중 일부의 데이터는 보안과 같은 여러가지 이유로 전송을 하고 싶지 않다. 이러한 변수는 직렬화에서 제외해야 하며, 이를 위해서 변수 transient를 선언한다.
- 직렬화 해야 되는 객체 중 Serializable 인터페이스가 구현되지 않으면서 전송하지 않아도 되는 객체 앞에는 transient를 선언해준다. 그러면 직렬화 대상에서 제외되므로 해당 객체는 직렬화가 가능해진다.

## 직렬화 조건
- 자바 기본(primitive) 타입과 java.io.Serializable 인터페이스를 상속받은 객체는 직렬화 할 수 있는 기본 조건을 가진다.
- 자바 직렬화는 java.io.ObjectOutputStream 객체를 이용한다.
- 해당 객체의 멤버들 중에 Serializable 인터페이스가 구현되지 않은 것이 존재하면 안된다.
- transient가 사용된 멤버는 전송되지 않는다. (보안변수 : null 전송)

## 역직렬화 조건
- 직렬화 대상이 된 객체의 클래스가 클래스 패스에 존재해야 하며 import 되어 있어야 한다.
- 자바 직렬화 대상 객체는 동일한 serialVersionUID를 가지고 있어야 한다.

## 데이터 직렬화 종류
- 문자열 형태의 직렬화 방법 : 직접 데이터를 문자열 형태로 확인 가능한 직렬화 방법이다. 범용적인 API나 데이터를 변환하여 추출할 때 많이 사용된다. 표 형태의 다량의 데이터를 직렬화시 CSV가 많이 쓰이고 구조적인 데이터는 이전에는 XML을 많이 사용했으며 최근에는 JSON형태를 많이 사용하고 있다.
<ul>
  <li>CSV : 데이터를 표현하는 가장 많이 사용되는 방법 중 하나로 콤마(,) 기준으로 데이터를 구분하는 방법이다. 자바에서는 Apache Commons CSV, openscv등의 라이브러리 등을 사용 가능하다. ex) 김배민,delivery@baemin.com</li>
  <li>JSON : 최근에 가장 많이 사용하는 포맷으로 자바스크립트에서 쉽게 사용 가능하고, 다른 데이터 포맷 방식에 비해 오버헤드가 적기 때문에 인기가 많다. 자바에서는 Jackson,GSON 등의 라이브러리를 이용해서 변환할 수 있다.</li>
</ul>
- CSV 같은 경우 표 형태의 데이터에서 많이 사용되며, JSON 같은 경우는 구조적인 데이터를 전달하는 API 시스템 등에서 많이 사용하고 있다.

- 이진 직렬화 방법 : 데이터 변환 및 전송 속도에 최적화하여 별도의 직렬화 방법을 제시하는 구조이다. 종류로는 Protocol Buffer, Apache Avro 등이 있다.
<ul>
  <li>Protocol Buffer : 프로토콜 버퍼는 구글에서 제안한 플랫폼 독립적인 데이터 직렬화 플랫폼이다. 자바에서 프로토콜 버퍼는 특정 언어 또는 플랫폼에 종속되지 않는 방법을 구현하기 위해 직렬화 하기 위한 데이터를 표현하기 위한 문서가 따로 있다. xx.proto  문서를 프로토콜 버퍼 컴파일러를 이용해서 개발하기 원하는 언어로 변환해야 한다. 자바 직렬화와 다른 점은 데이터 스펙을 표현하기 위한 문서가 존재하는 부분이다.</li>
</ul>

## 자바 직렬화
- 장점 : 자바 직렬화는 자바 시스템에서 개발에 최적화되어 있다. 복잡한 데이터 구조의 클래스의 객체라도 직렬화 기본 조건만 지키면 큰 작업 없이 바로 직렬화가 가능하다. 역직렬화도 마찬가지다. 데이터 타입이 자동으로 맞춰지기 때문에 관련 부분을 신경쓰지 않아도 된다. 역직렬화가 되면 기존 객체처럼 바로 사용할 수 있게 된다.
- 자바 직렬화는 언제 사용되는가? : JVM의 메모리에서만 상주되어있는 객체 데이터를 그대로 영속화가 필요할 때 사용된다. 시스템이 종료되더라도 없어지지 않는 장점을 가지며 영속화된 데이터이기 때문에 네트워크로 전송도 가능하다. 필요할 때 직렬화 된 객체 데이터를 가져와서 역직렬화하여 객체를 바로 사용할 수 있게 된다.
<ol>
  <li>서블릿 세션(Servlet Session) : 서블릿 기반의 WAS(톰캣, 웹로직 등)들은 대부분 세션의 자바 직렬화 지원하고 있다. 물론 단순히 세션을 서블릿 메모리 위에서 운용한다면 직렬화를 필요로 하지 않지만, 파일로 저장하거나 세션 클러스터링, DB를 저장하는 옵션 등을 선택하게 되면 세션 자체가 직렬화가 되어 저장되어 전달된다.</li>
  <li>캐시(Cache) : 자바 시스템에서 퍼포먼스를 위해 캐시 라이브러리를 시스템으로 많이 이용하게 된다. 자바 시스템을 개발하다 보면 상당수의 클래스가 만들어지게 되는데 캐시를 이용하면 DB에 대한 리소스를 절약할 수 있기 때문에 많은 시스템에서 자주 활용된다.</li>
  <li>자바 RMI(Remote Method Invocation) : 최근에는 많이 사용하지 않지만 원격 시스템 간의 메시지 교환을 위해서 사용하는 자바에서 지원하는 기술이다. 보통은 원격의 시스템과의 통신을 위해서 IP와 포트를 이용해서 소켓통신을 해야 하지만 RMI는 그 부분을 추상화하여 원격에 있는 시스템의 메서드를 로컬 시스템의 메서드인 것처럼 호출할 수 있다. 원격의 시스템의 메서드를 호출 시에 전달하는 메시지(보통 객체)를 자동으로 직렬화 시켜 사용된다. 그리고 전달받은 원격 시스템에서는 메시지를 역직렬화를 통해 변환하여 사용된다. </li>
</ol>

## serialVersionUID를 선언하는 이유
- 모든 클래스는 UID를 가지고 있는데 클래스의 내용이 변경되면 UID값 역시 같이 바뀌어 버린다. 직렬화하여 통신하고 UID값으로 통신한게 정상인지 확인하는데 그 값이 바뀌게 되면 다른 Class로 인식을 하게 된다. 이를 방지하기 위해 고유값으로 미리 명시를 해주는 부분이 "private static final long serialVersionUID"이다.
- Serializable을 상속하는 Class의 경우 Class의 versioning 용도로 serialVersionUID 변수를 사용한다. 이때 serialVersionUID 값을 명시적으로 지정하지 않으면 Complier가 계산한 값을 부여하는데 Serializable Class 또는 Outer Class에 변경이 있으면 serialVersionUID 값이 바뀌게 된다. 잠재적인 문제는 Serialize 할 때와 Deserialize할때의 값이 다르면 InvalidClassExceptions이 발생하여 저장된 값을 객체로 Restore할 수 없다.
- 즉, serialVersionUID를 지정하지 않으면 컴파일러가 계산한 값을 부여한다. 그렇다면 컴파일러에 따라 할당되는 값이 다를 수 있다. 컴파일러는 serializable class 또는 outer class를 참고하여 만들기 때문에 만약 클래스에 변경이 있으면 serialVersionUID도 변경이 있을 수 있다.

## CSV 라이브러리
- numpy : 수학,과학 수치 연산
- pandas : 빅데이터 분석
- matplotlib : 그래프 생성, 데이터 시각화
- requests : 크롤링, 다른 사이트의 내용을 긁어옴
- sklearn : 딥러닝 기능
- wordcloud : 워드 클라우드
- konlpy : 한글 형태소 분석, 음성 인식에선 필수로 쓰임
