## Serialization
- 직렬화란? : 자바 시스템 내부에서 사용되는 Obejct 또는 Data를 외부의 자바 시스템에서도 사용할 수 있도록 byte 형태로 데이터를 변환하는 기술. JVM의 메모리에 상주(힙 또는 스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술
- 역직렬화(Deserialization) : byte로 변환된 Data를 원래대로 Obejct나 Data로 변환하는 기술을 역직렬화라고 부른다. 직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM으로 상주시키는 형태.
- 자바 직렬화 형태의 데이터 교환은 자바 시스템 간의 데이터 교환을 위해서 존재한다.

## transient
- 객체의 데이터 중 일부의 데이터는 보안과 같은 여러가지 이유로 전송을 하고 싶지 않다. 이러한 변수는 직렬화에서 제외해야 하며, 이를 위해서 변수 transient를 선언한다.
- 직렬화 해야 되는 객체 중 Serializable 인터페이스가 구현되지 않으면서 전송하지 않아도 되는 객체 앞에는 transient를 선언해준다. 그러면 직렬화 대상에서 제외되므로 해당 객체는 직렬화가 가능해진다.

## 직렬화 조건
- 자바 기본(primitive) 타입과 java.io.Serializable 인터페이스를 상속받은 객체는 직렬화 할 수 있는 기본 조건을 가진다.
- 자바 직렬화는 java.io.ObjectOutputStream 객체를 이용한다.
- 해당 객체의 멤버들 중에 Serializable 인터페이스가 구현되지 않은 것이 존재하면 안된다.
- transient가 사용된 멤버는 전송되지 않는다. (보안변수 : null 전송)

## 역직렬화 조건
- 직렬화 대상이 된 객체의 클래스가 클래스 패스에 존재해야 하며 import 되어 있어야 한다.
- 자바 직렬화 대상 객체는 동일한 serialVersionUID를 가지고 있어야 한다.

## 데이터 직렬화 종류
- 문자열 형태의 직렬화 방법 : 직접 데이터를 문자열 형태로 확인 가능한 직렬화 방법이다. 범용적인 API나 데이터를 변환하여 추출할 때 많이 사용된다. 표 형태의 다량의 데이터를 직렬화시 CSV가 많이 쓰이고 구조적인 데이터는 이전에는 XML을 많이 사용했으며 최근에는 JSON형태를 많이 사용하고 있다.
<ul>
  <li>CSV : 데이터를 표현하는 가장 많이 사용되는 방법 중 하나로 콤마(,) 기준으로 데이터를 구분하는 방법이다. 자바에서는 Apache Commons CSV, openscv등의 라이브러리 등을 사용 가능하다. ex) 김배민,delivery@baemin.com</li>
  <li>JSON : 최근에 가장 많이 사용하는 포맷으로 자바스크립트에서 쉽게 사용 가능하고, 다른 데이터 포맷 방식에 비해 오버헤드가 적기 때문에 인기가 많다. 자바에서는 Jackson,GSON 등의 라이브러리를 이용해서 변환할 수 있다.</li>
</ul>
- CSV 같은 경우 표 형태의 데이터에서 많이 사용되며, JSON 같은 경우는 구조적인 데이터를 전달하는 API 시스템 등에서 많이 사용하고 있다.

- 이진 직렬화 방법 : 데이터 변환 및 전송 속도에 최적화하여 별도의 직렬화 방법을 제시하는 구조이다. 종류로는 Protocol Buffer, Apache Avro 등이 있다.
<ul>
  <li>Protocol Buffer : 프로토콜 버퍼는 구글에서 제안한 플랫폼 독립적인 데이터 직렬화 플랫폼이다. 자바에서 프로토콜 버퍼는 특정 언어 또는 플랫폼에 종속되지 않는 방법을 구현하기 위해 직렬화 하기 위한 데이터를 표현하기 위한 문서가 따로 있다. xx.proto  문서를 프로토콜 버퍼 컴파일러를 이용해서 개발하기 원하는 언어로 변환해야 한다. 자바 직렬화와 다른 점은 데이터 스펙을 표현하기 위한 문서가 존재하는 부분이다.</li>
</ul>

## 자바 직렬화
- 장점 : 자바 직렬화는 자바 시스템에서 개발에 최적화되어 있다. 복잡한 데이터 구조의 클래스의 객체라도 직렬화 기본 조건만 지키면 큰 작업 없이 바로 직렬화가 가능하다. 역직렬화도 마찬가지다. 데이터 타입이 자동으로 맞춰지기 때문에 관련 부분을 신경쓰지 않아도 된다. 역직렬화가 되면 기존 객체처럼 바로 사용할 수 있게 된다.
- 자바 직렬화는 언제 사용되는가? : JVM의 메모리에서만 상주되어있는 객체 데이터를 그대로 영속화가 필요할 때 사용된다. 시스템이 종료되더라도 없어지지 않는 장점을 가지며 영속화된 데이터이기 때문에 네트워크로 전송도 가능하다. 필요할 때 직렬화 된 객체 데이터를 가져와서 역직렬화하여 객체를 바로 사용할 수 있게 된다.
<ol>
  <li>서블릿 세션(Servlet Session) : 서블릿 기반의 WAS(톰캣, 웹로직 등)들은 대부분 세션의 자바 직렬화 지원하고 있다. 물론 단순히 세션을 서블릿 메모리 위에서 운용한다면 직렬화를 필요로 하지 않지만, 파일로 저장하거나 세션 클러스터링, DB를 저장하는 옵션 등을 선택하게 되면 세션 자체가 직렬화가 되어 저장되어 전달된다.</li>
  <li>캐시(Cache) : 자바 시스템에서 퍼포먼스를 위해 캐시 라이브러리를 시스템으로 많이 이용하게 된다. 자바 시스템을 개발하다 보면 상당수의 클래스가 만들어지게 되는데 캐시를 이용하면 DB에 대한 리소스를 절약할 수 있기 때문에 많은 시스템에서 자주 활용된다.</li>
  <li>자바 RMI(Remote Method Invocation) : 최근에는 많이 사용하지 않지만 원격 시스템 간의 메시지 교환을 위해서 사용하는 자바에서 지원하는 기술이다. 보통은 원격의 시스템과의 통신을 위해서 IP와 포트를 이용해서 소켓통신을 해야 하지만 RMI는 그 부분을 추상화하여 원격에 있는 시스템의 메서드를 로컬 시스템의 메서드인 것처럼 호출할 수 있다. 원격의 시스템의 메서드를 호출 시에 전달하는 메시지(보통 객체)를 자동으로 직렬화 시켜 사용된다. 그리고 전달받은 원격 시스템에서는 메시지를 역직렬화를 통해 변환하여 사용된다. </li>
</ol>

## serialVersionUID를 선언하는 이유
- 모든 클래스는 UID를 가지고 있는데 클래스의 내용이 변경되면 UID값 역시 같이 바뀌어 버린다. 직렬화하여 통신하고 UID값으로 통신한게 정상인지 확인하는데 그 값이 바뀌게 되면 다른 Class로 인식을 하게 된다. 이를 방지하기 위해 고유값으로 미리 명시를 해주는 부분이 "private static final long serialVersionUID"이다.
- Serializable을 상속하는 Class의 경우 Class의 versioning 용도로 serialVersionUID 변수를 사용한다. 이때 serialVersionUID 값을 명시적으로 지정하지 않으면 Complier가 계산한 값을 부여하는데 Serializable Class 또는 Outer Class에 변경이 있으면 serialVersionUID 값이 바뀌게 된다. 잠재적인 문제는 Serialize 할 때와 Deserialize할때의 값이 다르면 InvalidClassExceptions이 발생하여 저장된 값을 객체로 Restore할 수 없다.
- 즉, serialVersionUID를 지정하지 않으면 컴파일러가 계산한 값을 부여한다. 그렇다면 컴파일러에 따라 할당되는 값이 다를 수 있다. 컴파일러는 serializable class 또는 outer class를 참고하여 만들기 때문에 만약 클래스에 변경이 있으면 serialVersionUID도 변경이 있을 수 있다.
- 가능하면 모든 직렬화 가능 클래스가 명시적으로 선언하는 것을 추천한다. 디폴트의 serialVersionUID의 계산이, 컴파일러의 구현에 따라서 달라질 직렬화 가능Serializable 클래스가 영향을 받기 쉽고, 직렬화 복원중에 InvalidClassExceptions을 발생시킬 수 있기 때문. 따라서,  컴파일러에 상관없이 일관성을 확보하기 위해서 명시적으로 선언하는 것이 좋다. private으로 선언하면 serialVersionUID값이 상속되지 않는다.
- 배열클래스는 serialVersionUID를 명시적으로 선언할 수 없기 때문에, 디폴트 값을 사용한다.

## CSV 라이브러리
- numpy : 수학,과학 수치 연산
- pandas : 빅데이터 분석
- matplotlib : 그래프 생성, 데이터 시각화
- requests : 크롤링, 다른 사이트의 내용을 긁어옴
- sklearn : 딥러닝 기능
- wordcloud : 워드 클라우드
- konlpy : 한글 형태소 분석, 음성 인식에선 필수로 쓰임

## XML 라이브러리
- SAX 파서 : Simple API for XML Parser의 약어로, Java API에서 제공된다. 기본적으로 SAX Parser는 노드들이 들어올때마다 event가 발생하면서 순차적으로 parsing을 하게 된다. 그래서 어떤 노드에 무작위 적으로 접근을 하기 위해서는 이 node들을 사용자가 트리구조로 생성한뒤, 메모리에 올려서 사용하여야 한다. XML이 복잡하지 않고, 메모리를 최소화 하면서 최대한 빠른 처리가 필요할 때 사용. 장점 : 순차적으로 파싱을 하기 때문에 속도가 빠르고 메모리를 적게 먹는다. 단점 : 특정 노드를 무작위적으로 접근하는 random access를 할 수 없다. 
- DOM 파서 : xml test의 string들과 stream들을 parsing할 때 사용되는 것으로서, XML을 parsing 하면서, 트리구조를 만들고 이 트리구조 전체를 메모리 상에 로드 시킨다. 메모리는 좀 소모되지만 생산성, XML 오브젝트 핸들링, 성은이 필요할 때 사용. 장점 : 사용법이 간단하고, 트리구조 전체를 볼수 있다. 단점 : 메모리를 많이 먹고, 조금 느리다.
- StAX : Streaming API for XML. 자바 1.6부터 포함된 Paeser API. SAX와 DOM의 장점을 보완한 새로운 파서 API 모델. push와 pull방식을 동시에 제공하는 형태. XML문서를 파싱할 때 하나의 Fragment로 구분한다. 즉 정해진 엘리먼트를 읽을때는 Dom 방식을 사용해서 Fragment로 처리하는 것은 SAX의 Push 방식을 사용하고 있다. 실제 파서는 JAXB를 사용하고 Rading 정책은 StAX형식을 따르는 것이 좋은 조합. 속도는 JAXB보다 느리지만, 메모리 소모가 적은 경우 사용.
- JAXB : Java Architecture for XML Bind. XML로 부터 Java Object를 직렬화 하는 Unmarshalling과 이 반대의 Marshalling을 수행할 수 있도록 해주는 API. 자바 클래스를 XML로 포현할 수 있게 해줌. JAXB는 메모리의 데이터를 XML 형식으로 변환하여 저장할 수 있고, 이 과정을 위해 프로그램의 각 클래스에서 XML을 읽고 저장하는 일을 구현해야 한다.

## Marshalling과 Serialization의 차이
- Marshalling : 객체의 메모리 구조를 저장이나 전송을 위해서 적당한 자료형태로 변형하는 것을 의미한다. Marshalling은 보통 서로 다른 컴퓨터 혹은 서로 다른 프로그램 간의 데이터가 이동되어야할 경우 사용된다. 직렬화와 비슷한 경우는 개체가 원격의 다른 객체와 통신할 때 serialize 된 객체를 사용할 경우이다. Marshalling을 수행함으로써 복잡한 통신, 사용자 정의/복잡한 구조의 객체들을 사용하는 대신, 단순한 primitive들을 사용할 수 있다. Marshalling의 반대말은 Unmarshalling.
- Marshalling을 하게 되면, 원격 프로시저를 호출하는 것에서 함수의 parameter 값들 return값들을 전달할 수 있다. 보통 Marshalling은 여기저기에서 parameter들을 얻는 반면, Serialization은 구조화된 데이터를 byte stream과 같은 primitive 형식 혹은 그 반대로 복사를 하는 것을 의미한다. 
- Marshalling은 코드베이스를 가져와 만드는 개념이고 Serialization은 객체 자체를 복사하는 개념이다.
