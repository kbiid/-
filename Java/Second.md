## Enum
- JDK 1.5부터 사용가능. 열거형이라 불리며, 서로 연관된 상수들의 집합을 의미한다.
- enum 이전에는 다음과 같은 방식으로 열거형 상수를 선언했다.
<ul>
  <li>클래스 내에 final static로 변수 선언</li>
  <li>interface에 상수 선언</li>
</ul>

- 기존 방식의 문제 : 한 클래스에 final static으로 선언하려면 네임충돌의 가능성과 복잡함. 인터페이스를 사용하면 해결이 되나, 타입 안정성이 떨어짐.
- 장점
<ul>
  <li>코드가 단순해지며, 가독성이 좋다.</li>
  <li>인스턴스 생성과 상속을 방지하여 상수값의 타입안정성이 보장된다.</li>
  <li>enum class를 사용해 새로운 상수들의 타입을 정의함으로 정의한 타입 이외의 타입을 가진 데이터값을 컴파일시 체크한다.</li>
  <li>키워드 enum을 사용하기 때문에 구현의 의도가 열거임을 분명하게 알 수 있다.</li>
</ul>

## Generic 
- 제네릭의 장점
<ul>
  <li>컴파일 시 강한 타입 체크를 할 수 있다 : 자바 컴파일러는 코드에서 잘못 사용된 타입 때문에 발생하는 문제점을 제거하기 위해 제네릭 코드에 대해 강한 타입 체크를 한다. 실행 시 타입 에러가 나는 것보다는 컴파일 시에 미리 타입을 강하게 체크해서 에러를 사전에 방지하는 것이 좋다.</li>
  <li>타입 변환(casting)을 제거한다 : 비제네릭 코드는 불필요한 타입 변환을 하기 때문에 프로그램 성능에 악영향을 끼친다. 제네릭 코드는 타입 변환을 할 필요가 없어 프로그램 성능이 향상된다./li>
</ul>

- Java5부터 제네릭 타입이 추가.
- 제네릭 타입은 타입을 파라미터로 가지는 클래스와 인터페이스를 말한다. 제네릭 타입은 클래스 또는 인터페이스 이름 뒤에 "<>" 부호가 붙고, 사이에 타입 파라미터가 위치한다. -> public class 클래스명<T> {....}
- Object 타입을 사용하면 모든 종류의 자바 객체를 저장할 수 있다는 장점은 있지만, 저장할 때 타입 변환이 발생하고, 읽어올 때에도 타입 변환이 발생한다. 타입 변환이 빈번해지면 전체 프로그램 성능에 좋지 못한 결과를 가져올 수 있다. 모든 종류의 객체를 저장하면서 타입 변환이 발생하지 않도록 하기 위해서 제네릭을 사용한다.
- 자바7부터 제네릭 타입 파라미터의 중복 기술을 줄이기 위해 다이아몬드 연산자 <>를 제공한다.
-> Product<Tv, String> product = new Product<>();
  
## Generic Method
- 제네릭 메소드는 매개 타입과 리턴 타입으로 타입 파라미터를 갖는 메소드를 말한다.
  
## Call by value , Call by reference
- Call by value : 메소드 호출 시에 사용되는 인자의 메모리에 저장되어 있는 값을 복사하여 보낸다.
- Call by refenrece : 메소드 호출 시 사용되는 인자 값의 메모리에 저장되어 있는 주소를 복사하여 보낸다.
- 다른 메소드에서 현재의 메소드 내의 변수 값을 바꾸는 현상을 사이트 이펙트(side effect)라고 한다. 사이드 이펙트는 메소드 간의 값 전달을 쉽게 하기 때문에 편리하지만, 실수로 프로그래머가 모르는 사이에 값이 바뀌면 심각한 문제를 일으킬 수 있기 때문에 위험하다. 그래서 자바는 모든 기본 데이터형은 Call by Value로 값을 주고 받아서 사이드 이펙트가 일어나지 않도록 하고, Call by Reference가 필요한 경우 명시적으로 클래스 객체를 주고받도록 정해둔 것이다.

## String vs StringBuffer vs StringBuilder
- String은 immutable(불변)하고 StringBuffer, StringBuilder는 mutable(가변)하다.
- String은 new 연산을 통해 생성되면 그 인스턴스의 메모리 공간은 절대 변하지 않는다. 그래서 + 연산이나 concat을 이용해서 문자열에 변화를 줘도 메모리 공간이 변하는 것이 아니라 새로운 String객체를 new로 만들어서 새로운 메모리 공간을 만드는 것이다. 즉, String 클래스 객체는 Heap 메모리 영역에 생성). 이 때문에 시스템 자원(시간 , 메모리) 등이 낭비될 여지가 있다.
- 이렇게 새로운 문자열이 만들어지면 기존의 문자열은 가비지 콜렉터에 의해 제거되야 하는 단점(언제 제거될지 모름)이 있다.
- 이러한 문자열 연산이 많아질 때 계속해서 객체를 만드는 오버헤드가 발생하므로 성능이 떨어질 수 밖에 없는 단점이 있다.(+연산에 내부적으로 char배열을 사용함)
- 대신 String 클래스의 객체는 불변하기 때문에 단순하게 읽어가는 조회연산에서는 타 클래스보다 빠르게 읽을 수 있다. 또한 불변하기 때문에 멀티쓰레드환경에서 동기화를 신경 쓸 필요가 없다는 장점들이 있다. 즉, String 클래스는 문자열 연산이 적고 조회가 많을 때 멀티쓰레드 환경에서 사용하면 좋다.
- String이 immutable인 이유는 안정성 때문이다. 읽기 목적이 뚜렷한 String 생성시 처음에만 문자열을 할당하고 그 이후엔 수정하지 말고, 읽기만 하라는 것이다. immutable 클래스의 가장 큰 장점은 안전하게 공유될 수 있다는 점이다. 여러 쓰레드나 객체에서 참조하는 경우 synchronization(동기화) 없이도 데이터가 안전하게 공유되기 때문이다. 따라서 변경하지 않고 읽기용 또는 공유 목적 하에 있는 문자열은 String immutable 클래스를 사용하는 것이 바람직하다.
- StringBuffer와 StringBuilder 클래스는 String과 다르게 mutable(변경가능)하다. 즉, 문자열 연산에 있어서 클래스를 한번만 만들고(new), 연산이 필요할 때 크기를 변경시켜서 문자열을 변경한다. 그러므로 문자열 연산이 자주 있을 때 사용하면 성능이 좋다.
- StringBuffer와 StringBuilder의 차이는?
<ul>
  <li>StringBuffer는 멀티쓰레드환경에서 synchronized키워드가 가능하므로 동기화가 가능하다. 즉,thread-safe하다.</li>
  <li>StringBuilder는 JDK 1.5에서 새롭게 추가된 클래스이며, 동기화를 지원하지 않기 때문에 멀티쓰레드환경에서는 적합하지 않다. 대신 StringBuilder가 동기화를 고려하지 않기 때문에 싱글드 환경에서 StringBuffer에 비해 연산처리가 빠르다.</li>
</ul>
- 결론 : 문자열 연산이 많을 때 멀티쓰레드환경에서는 StringBuffer, 싱글쓰레드 또는 쓰레드를 신경쓰지 않아도 되는 환경에서는 StringBuilder를 사용하는 것이 좋다.
- JDK 1.5 이상부터 String에서 +연산으로 작성하더라고 StringBuilder로 컴파일하게 만들어서 성능적인 차이는 거의 없지만 여전히 String 클래스의 객체 생성하는 부분이 동일하므로 StringBuffer,StringBuilder 사용이 필요함
- String이 왜 Immutable인가? : http://www.mimul.com/pebble/default/2015/10/10/1444466677572.html

## mutable, immutable
- mutable 객체는 객체 내의 특정 요소를 변경할 수 있는 객체이다. List, ArrayList, HashMap 등의 컬렉션들이 대표적인 mutable 객체이다.
- immutable 객체는 객체 내의 특정 요소의 값을 변경 할 수 없는 개체이다. String, Integer, Double, Long과 같은 객체는 대표적인 immutable 객체이다.
