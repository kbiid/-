## Java 버전별 특징

# Java7
- try-with-resources : try에 자원객체를 전달하면 finally 블록으로 종료 처리를 하지 않아도 try 코드 블록이 끝나면 자동으로 자원을 종료해주는 기능.
- 멀티캐치(multicatch) : 하나의 catch 블록에서 동시에 여러 예외를 묶어서 처리할 수 있도록 하는 기능
- swtich-case의 문자열 지원
- fork/join을 이용한 작업 분할 실행
- ECC 암호화 기본 내장

# Java8
- 람다 표현식(lambda expression) : 함수형 프로그래밍
- 스트림 API(stream API) : 데이터의 추상화
- java.time 패키지 : Joda-Time을 이용한 새로운 날짜와 시간 API
- 나즈혼(Nashorn) : 자바스크립트의 새로운 엔진

- 출처 : http://tcpschool.com/java/java_intro_java8

# Java9
- Java Jigsaw : 유연한 런타임 이미지를 만들 수 있도록 Java 플랫폼을 묘듈화 하기 위한 것.
- 출처 : https://greatkim91.tistory.com/197
- 이외의 특징들 : https://medium.com/@goinhacker/java-9%EC%9D%98-%EB%B3%80%ED%99%94%EC%99%80-%ED%8A%B9%EC%A7%95-%EB%8C%80%EC%B6%A9-%EC%A0%95%EB%A6%AC-fca77cee88f2

# Java10
- Local-Variable Type Inference : 로컬변수 선언을 var를 이용하여 선언 가능
- 출처 : https://itstory.tk/entry/Java-10-%EC%8B%A0%EA%B7%9C-%EA%B8%B0%EB%8A%A5%ED%8A%B9%EC%A7%95-%EC%A0%95%EB%A6%AC

## 오라클 JDK vs Open JDK
- 폐쇄적인 상업코드 기반의 Oracle JDK. 오픈 소스 기반의 Open JDK
- Oracle JDK는 Open JDK에 없는 재산권이 걸린 플러그인 제공. 해당 플러그인은 Oracle이 재산권 보유.
- Oracle JDK만 존재하는 대표적 기능 -> 글꼴 라이브러리, Java Web Start
- https://jsonobject.tistory.com/395

## 얕은 복사 vs 깊은 복사
- Shallow copy : 배열이나 객체를 복사할 때 단순히 참조만 복사하는 것으로써 원본이 변경되면 복사본도 같이 변경됨.
- Deep copy : 데이터만 복사하고 주소는 달라서 값을 변경해도 영향을 주지 않는다.

## 1부터 100까지 더하는 방식?
- 반복문
- 재귀함수
- intstream : IntStream.rangeClosed(1, 99).sum()

## 객체지향의 4대 법칙
- 추상화(Abstraction) : 객체에서 공통된 속성과 행위를 추출하는 것을 추상화라고 한다.
- 상속 : 클래스의 속성과 행위를 하위 클래스에 물려주거나, 상위 클래스에서 물려받는 것을 지칭한다. 상속을 사용하면 재사용으로 인한 코드가 줄어들며 좀 더 범용성 있게 사용할 수 있다.
- 다형성 : 객체지향의 개념에서 가장 중요한 특징. 사전적 의미로 '다양한 형태로 나타날 수 있는 능력'. 객체지향 프로그래밍은 하나의 클래스 내부에 같은 이름의 행위를 여럿 정의하거나, 상위 클래스의 오퍼레이션을 하위 클래스에서 다시 정의하여 사용할 수 있기 때문에 이 다형성이라는 특징을 갖는다.
※ 객체지향 프로그래밍에서 다형성 구현 방법
- 메소드 오버로딩 : 클래스 내부에 동일한 이름의 행위를 여럿 정의하는 것. 
<ol>
  <li>함수명은 같아야 한다.</li>
  <li>파라미터의 타입과 개수는 서로 달라야 한다.</li>
  <li>리턴타입은 관계없다.</li>
</ol>
- 메소드 오버라이딩 : 상속으로 물려받은 자료나 메소드를 그대로 사용하지 않고 자신이 새로 만들어 사용하는 것.
<ol>
  <li>함수명은 같아야 한다.</li>
  <li>파라미터의 타입과 개수는 동일해야 한다.</li>
  <li>리턴타입은 같아야 한다.</li>
</ol>

- 캡슐화(Encapsuation) : 정보은닉. 객체의 상세한 내용을 객체 외부에 철저히 숨기고 단순히 메시지만으로 객체와의 상호작용을 하게 되는 것을 말한다.

## static 메소드와 인스턴스 메소드
- static 메소드(클래스 메소드) : 객체를 생성하지 않고 '클래스이름.메소드이름(매개변수)'와 같은 식으로 호출이 가능하다. 반면에 인스턴스 메소드는 반드시 객체를 생성해야만 호출할 수 있따.
- 인스턴스 메소드 : 인스턴스 변수와 관련된 작업을 하는, 즉 메소드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메소드이다.
- static(클래스) 메소드 : 인스턴스와 관계없는(인스턴스 변수나 인스턴스 메소드를 사용하지 않는) 메소드를 클래스 메소드(static메소드)로 정의한다.
<ol>
  <li>클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static을 붙인다.</li>
  <li>클래스 변수(static변수)는 인스턴스를 생성하지 않아도 사용할 수 있다. -> static이 붙은 변수는 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문이다.</li>
  <li>클래스 메소드는 인스턴스 변수를 사용할 수 없다. -> 클래스 메소드는 인스턴스 생성 없이 호출가능하므로 클래스 메소드가 호출되었을 때 인스턴스가 존재하지 않을 수 있다. 반면 인스턴스 변수나 인스턴스 메소드에서는 static이 붙은 멤버들을 언제나 사용할 수 있다.</li>
  <li>메소드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다. -> 메소드 호출시간이 짧아지므로 성능이 향상된다. static을 안붙인 메소드는 실행 시 호출되어야할 메소드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더걸린다.</li>
</ol>

## inner class, nested class, local clas, anonymous class
- 내부 클래스(inner class) : 다른 클래스 내부에서 정의된 클래스
<ol>
  <li>멤버 내부 클래스(member class) : 멤버 변수를 선언하는 위치에서 정의하는 내부 클래스. 외부 클래스의 인스턴스가 생성되어야먄 객체 생성이 가능함</li>
  <li>static 내부 클래스(static inner class), 중첩 클래스(nested class) : 멤버 변수를 선언하는 위치에서 static으로 정의한 내부 클래스. 외부 클래스의 인스턴스를 생성하지 않아도 객체 생성이 가능함. 외부 클래스와 상관이 없는 클래스라고 생각해도 됨.</li>
  <li>지역 내부 클래스(local inner class)
    - 메소드 안에서 정의하는 클래스. 이름이 있는 local 클래스.
    - 이름이 없는 local 클래스 : 익명 클래스(anonymous class) -> 람다 표현식(lambda expression)</li>
</ol>

## 초기화 블록
- 초기화 블록이란 클래스 필드의 초기화만을 담당하는 중괄호({})로 둘러싸인 블록. static 키워드의 유무에 따라 인스턴스 초기화 블록과 클래스 초기화 블록으로 구분할 수 있다. 복잡한 초기화를 해야 할 경우 유용하게 사용된다.
- 모든 생성자가 실행되기 전에 실행되는 것이 초기화 블럭.
ex) 클래스 이름 {
      {
        초기화 블럭 내용;
      }
      생성자(){
        생성자 이름;
      }
    } 
<ul>
  <li>인스턴스 초기화 블록 : 단순히 중괄호만을 사용하여 정의할 수 있음. 생성자와 마찬가지로 인스턴스가 생성될 때마다 실행된다. 언제나 인스턴스 초기화 블록이 생성자보다 먼저 실행된다. 생성자와 인스턴스 초기화 블록의 차이는 거의 없으므로 인스턴스 초기화 블록은 잘 사용되지 않는다. 단, 여러 개의 생성자가 있으면 모든 생성자에서 공통으로 수행되어야 할 코드를 인스턴스 초기화 블록에 포함하여 코드의 중복을 막을 수 있다.</li>
  <li>클래스 초기화 블록 : 인스턴스 초기화 블록에 static 키워드를 추가하여 정의할 수 있다. 클래스가 처음으로 메모리에 로딩될 때 단 한번만 실행된다. 클래스 초기화 블록은 생성자나 인스턴스 초기화 블록으로는 수행할 수 없는 클래스 변수의 초기화를 수행할 때 사용된다.</li>
</ul>
- http://tcpschool.com/java/java_member_initBlock
