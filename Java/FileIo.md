## NIO
- 자바 4부터 새로운 입출력(New Input Output)이라는 뜻에서 java.nio 패키지에 포함되었다. 자바 7로 버전업하면서 자바 IO와 NIO 사이의 일관성 없는 클래스 설계를 바로 잡고 비동기 채널 등의 네트워크 지원을 대폭 강화한 NIO.2 API가 추가되었다. NIO.2는 java.nio의 하위 패키지(java.nio.channels,java.nio.file에 통합되어 있음)

- NIO와 IO의 차이점
<ol>
  <li>입출력 방식 : IO는 스트림 방식, NIO는 채널 방식.</li>
  <li>버퍼 방식 : IO는 넌버퍼, NIO는 버퍼.</li>
  <li>비동기 방식 : IO는 지원 안 함, NIO는 지원.</li>
  <li>블로킹/넌블로킹 방식 : IO는 블로킹 방식만 지원, NIO는 블로킹/ 넌블로킹 방식 모두 지원</li>
</ol>

- 스트림과 채널 : IO는 스트림 기반 -> 스트림은 입력 스트림과 출력 스트림이 구분되어 있음. 데이터를 읽기 위해 입력 스트림을 생성, 데이터 출력 위해 출력 스트림 생성 해야함. NIO는 채널 기반 -> 채널은 스트림과는 다르게 양방향 입출력 가능. 때문에 입력과 출력을 위한 별도의 채널을 만들 필요 없음.
- 넌버퍼와 버퍼 : 
<ol>
  <li>IO에서는 출력 스트림이 1바이트를 쓰면 입력 스트림이 1바이트를 읽음 -> 이런 시스템은 대체로 느림 -> 버퍼를 사용하여 복수 개의 바이트를 한번에 입력받고 출력하는 것이 좋음. -> IO는 버퍼를 제공해주는 보조 스트림인 BufferedInputStream, BufferedOutputStream을 연결해서 사용하기도 함.</li>
  <li>NIO는 기본적으로 버퍼를 사용하여 입출력을 함. -> IO보다 성능이 좋음. 채널은 버퍼에 저장된 데이터를 출력하고 입력된 데이터를 버퍼에 저장.</li>
  <li>IO는 스트림에서 읽은 데이터를 즉시 처리하므로 스트림으로부터 입력된 전체 데이터를 별도로 저장하지 않으면 입력된 데이터의 위치를 이동해 가며 자유롭게 이용할 수 없음.</li>
  <li>NIO는 읽은 데이터를 무조건 버퍼에 저장 -> 데이터의 위치를 이동해 가며 필요한 부분만 읽고 쓸수 있음</li>
</ol>

- 블로킹과 넌블로킹
<ol>
  <li>IO는 블로킹 됨. 입력 스트림의 read()를 호출하면 데이터가 입력되기 전까지 스레드는 블로킹(대기상태)되고 출력 스트림의 write()를 호출하면 데이터 출력 전까지 스레드는 블로킹됨. IO슬드가 블로킹되면 다른 일을 할 수 없고 블로킹을 빠져나오기 위해 인터럽트할 수도 없음. 유일한 방법을 스트림을 닫는 것임.</li>
  <li>NIO는 블로킹과 넌블로킹 특징을 모두 가짐. NIO블로킹은 스레드를 인터럽트함으로써 빠져나올 수 있다.</li>
  <li>넌블로킹이란 입출력 작업 시 스레드가 블로킹되지 않는 것을 의미한다. NIO의 넌블로킹은 입출력 작업 준비가 완료된 채널만 선택해서 작업 스레드가 처리하므로 작업 스레드가 블로킹되지 않음.</li>
  <li>NIO 넌블로킹의 핵심 객체는 멀티플레서인 셀렉터(Selector)이다. 셀렉터는 복수 개의 채널 중에서 준비완료된 채널은 선택하는 방법을 제공.</li>
</ol>

- IO와 NIO의 선택 : 
<ol>
<li>NIO는 불특정 다수의 클라이언트 연결이나 멀티 파일들을 넌블로킹이나 비동기 처리할 수 있다. -> 과도한 스레드 생성을 피하고 스레드를 효과적으로 재사용한다는 장점이 있다. 운영체제의 버퍼를 이용한 입출력이 가능하므로 입출력 성능 향상.</li>
<li>NIO는 연결 클라이언트 수가 많고 하나의 입출력 처리 작업이 오래걸리지 않는 경우에 사용하는 것이 좋음. 스레드에서 입출력 처리가 오래 걸린다면 대기하는 작업의 수가 늘어나므로 제한된 스레드 처리하는 것이 불편할 수 있음.</li>
<li>대용량의 데이터 처리의 경우 IO가 좋다. NIO는 버퍼 할당 크기가 문제가 된고, 모든 입출력 작업에 버퍼를 무조건 사용해야 하므로 IO보다 조금 더 복잡. IO로 서버를 구현하는 것이 좋음.</li>
</ol>
